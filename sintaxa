Require Import Strings.String.
Delimit Scope string_scope with string.
Local Open Scope string_scope.
Require Import Arith.
Require Import Ascii.
Require Import Bool.
Require Import Coq.Strings.Byte.
Scheme Equality for string.



Inductive ErrorNat :=
  | error_nat : ErrorNat
  | num : nat -> ErrorNat.

Inductive ErrorBool :=
  | error_bool : ErrorBool
  | boolean : bool -> ErrorBool.

Inductive ErrorString :=
  | error_string : ErrorString
  | stringg : string -> ErrorString.
 

Coercion num : nat >-> ErrorNat.
Coercion boolean : bool >-> ErrorBool.
Coercion stringg : string >-> ErrorString.

Inductive ValueTypes :=
| default : ValueTypes
| err_undeclared : ValueTypes
| err_assignment : ValueTypes
| natural : ErrorNat -> ValueTypes
| res_boolean : ErrorBool -> ValueTypes
| res_stringg : ErrorString -> ValueTypes.


Check 7.
Check true.
Check "ana".

Scheme Equality for ValueTypes.

Definition Env := string -> ValueTypes.


Definition env : Env := fun x => err_undeclared.
Compute (env "x").

Definition check_eq_over_types (t1 : ValueTypes) (t2 : ValueTypes) : bool :=
  match t1 with
    | err_undeclared => match t2 with 
                     | err_undeclared => true
                     | _ => false
                     end
    | default => match t2 with 
                  | default => true
                  | _ => false
                  end
    | err_assignment => match t2 with 
                  | err_assignment => true
                  | _ => false
                  end
    | natural _x => match t2 with
                  | natural _x => true
                  | _ => false
                  end
    | res_boolean _x => match t2 with 
                  | res_boolean _x => true
                  | _ => false
                  end
    | res_stringg _x => match t2 with
                  | res_stringg _x => true
                  | _ => false
                  end
  end.

Definition update (env : Env) (x : string) (v : ValueTypes) : Env :=
  fun y =>
    if (string_beq y x)
    then
       if(andb (check_eq_over_types err_undeclared (env y)) (negb (check_eq_over_types default v)))
       then err_undeclared
       else if((check_eq_over_types err_undeclared (env y)))
            then default
            else if(orb (check_eq_over_types default (env y)) (check_eq_over_types v (env y)))
                 then v
                  else err_assignment
    else (env y). 

Compute (env "y").
Compute (update (update env "y" (default)) "y" (res_boolean true) "y").
Compute ((update (update (update env "y" default) "y" (natural 10)) "y" (res_boolean true)) "y").


Inductive AExp :=
| avar : string -> AExp
| anum : ErrorNat -> AExp
| aplus : AExp -> AExp -> AExp
| amul : AExp -> AExp -> AExp
| aminus : AExp -> AExp -> AExp
| adiv : AExp -> AExp -> AExp
| amodulo : AExp -> AExp -> AExp.


Coercion anum : ErrorNat >-> AExp.
Coercion avar : string >-> AExp.

Notation "A +' B" := (aplus A B) (at level 60, right associativity).
Notation "A *' B" := (amul A B) (at level 58, left associativity).
Notation "A -' B" := (aminus A B) (at level 50, left associativity).
Notation "A /' B" := (adiv A B) (at level 40, left associativity).
Notation "A %' B" := (amodulo A B) (at level 50, left associativity).

Definition plus_ErrorNat (n1 n2 : ErrorNat) : ErrorNat :=
  match n1, n2 with
    | error_nat, _ => error_nat
    | _, error_nat => error_nat
    | num v1, num v2 => num (v1 + v2)
    end.

Definition minus_ErrorNat (n1 n2 : ErrorNat) : ErrorNat :=
  match n1, n2 with
    | error_nat, _ => error_nat
    | _, error_nat => error_nat
    | num n1, num n2 => if Nat.ltb n1 n2
                        then error_nat
                        else num (n1 - n2)
    end.

Definition mul_ErrorNat (n1 n2 : ErrorNat) : ErrorNat :=
  match n1, n2 with
    | error_nat, _ => error_nat
    | _, error_nat => error_nat
    | num v1, num v2 => num (v1 * v2)
    end.

Definition div_ErrorNat (n1 n2 : ErrorNat) : ErrorNat :=
  match n1, n2 with
    | error_nat, _ => error_nat
    | _, error_nat => error_nat
    | _, num 0 => error_nat
    | num v1, num v2 => num (Nat.div v1 v2)
    end.

Definition modulo_ErrorNat (n1 n2 : ErrorNat) : ErrorNat :=
  match n1, n2 with
    | error_nat, _ => error_nat
    | _, error_nat => error_nat
    | _, num 0 => error_nat
    | num v1, num v2 => num (v1 - v2 * (Nat.div v1 v2))
    end.


Inductive BExp :=
| berror : BExp
| btrue : BExp
| bfalse : BExp
| bnot : BExp -> BExp
| band : BExp -> BExp -> BExp
| bor : BExp -> BExp -> BExp
| blessthan : AExp -> AExp -> BExp
| bgreaterthan : AExp -> AExp -> BExp
| bvar: string -> BExp.

Notation "! A" := (bnot A) (at level 70).
Notation "A 'and'' B" := (band A B) (at level 80).
Notation "A <' B" := (blessthan A B) (at level 70).
Notation "A >' B" := (bgreaterthan A B) (at level 70).
Notation "A 'or'' B" := (bor A B) (at level 85, right associativity).

Definition blessthan_ErrorBool (n1 n2 : ErrorNat) : ErrorBool :=
  match n1, n2 with
    | error_nat, _ => error_bool
    | _, error_nat => error_bool
    | num v1, num v2 => boolean (Nat.ltb v1 v2)
    end.

Definition greaterthan_ErrorBool (n1 n2 : ErrorNat) : ErrorBool :=
  match n1, n2 with
    | error_nat, _ => error_bool
    | _, error_nat => error_bool
    | num v1, num v2 => boolean (negb (Nat.ltb v1 v2))
    end.

Definition bnot_ErrorBool (n :ErrorBool) : ErrorBool :=
  match n with
    | error_bool => error_bool
    | boolean v => boolean (negb v)
    end.

Definition band_ErrorBool (n1 n2 : ErrorBool) : ErrorBool :=
  match n1, n2 with
    | error_bool, _ => error_bool
    | _, error_bool => error_bool
    | boolean v1, boolean v2 => boolean (andb v1 v2)
    end.

Definition bor_ErrorBool (n1 n2 : ErrorBool) : ErrorBool :=
  match n1, n2 with
    | error_bool, _ => error_bool
    | _, error_bool => error_bool
    | boolean v1, boolean v2 => boolean (orb v1 v2)
    end.

Inductive Stmt :=
| nat_decl : string -> AExp -> Stmt
| bool_decl : string -> BExp -> Stmt
| string_decl : string -> string -> Stmt
| nat_assignment : string -> AExp -> Stmt
| bool_assignment : string -> BExp -> Stmt
| string_assignment : string -> string -> Stmt
| sequence : Stmt -> Stmt -> Stmt
| ifthen : BExp -> Stmt -> Stmt
| ifthenelse : BExp -> Stmt -> Stmt -> Stmt
| while : BExp -> Stmt -> Stmt
| FOR : Stmt -> BExp -> Stmt -> Stmt.


Notation "X :n= A" := (nat_assignment X A)(at level 90).
Notation "X :b= A" := (bool_assignment X A)(at level 90).
Notation "X :s= A" := (string_assignment X A)(at level 90).
Notation "'iNat' X ::= A" := (nat_decl X A)(at level 90).
Notation "'iBool' X ::= A" := (bool_decl X A)(at level 90).
Notation "'iString' X ::= A" := (string_decl X A)(at level 90).
Notation "S1 ;; S2" := (sequence S1 S2) (at level 90).

(*Operatii pe string-uri*)

Inductive Strings :=
| string_var : string -> Strings
| string_string : ErrorString -> Strings
| strlen : ErrorString -> Strings
| strcat : ErrorString -> ErrorString -> Strings
| strcmp : ErrorString -> ErrorString -> Strings.


Coercion string_var: string >->Strings.


Notation " A +/ B " :=(strcat A B) (at level 60).


Check strlen "tema".
Check "proiect" +/ "plp".

Definition string_length (s : ErrorString) : ErrorNat :=
  match s with 
    | error_string => error_nat
    | stringg v1 => length v1
end.

Compute string_length "mama".


Definition concat_string (s1 : ErrorString) (s2 : ErrorString) : ErrorString :=
    match s1,s2 with 
    | error_string, _ => error_string
    | _, error_string => error_string
    | stringg v1, stringg v2 => v1 ++ v2
end.

Compute concat_string "a" "b".


Definition strcmp_string (s1 : ErrorString) (s2 : ErrorString) : ErrorString :=
    match s1,s2 with 
    | error_string, _ => error_string
    | _, error_string => error_string
    | stringg v1 , stringg v2 => if (Nat.leb (length v1) (length v2)) then v2
                                                                    else v1
end.

Compute strcmp_string "abcd" "abe".
